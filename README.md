# Домашнее задание от Академии Яндекса

Репозиторий представляет собой серию выполненных домашних заданий в рамках учебного курса для Java-backend разработчиков от Яндекса.


**Домашнее задание к 5 лекции**

## Условие


- Добавить ручку /v1/chats/search, которая в качестве обязательных аргументов принимает в запросе текст фразы, которую надо найти в сообщениях чатов. Поиск должен производиться только по тем чатам, где пользователь добавлен, а не по всем вообще. Ручке необходимо передавать session_id, чтобы она могла определить, о каком пользователе речь.
- Возвращает ручка отнюдь не результат в виде ссылок на чаты и сообщения, где эта фраза есть, поскольку это может быть достаточно тяжеловесный процесс, а идентификатор таски, статус которой мы будем периодически опрашивать.
- Надо будет добавить вторую ручку /v1/chats/search/status/{task_id}, которая будет позволять получать статус. Возвращать 200 и статус таски, если она есть, и 404, если такой таски вообще не существует. Ручке необходимо передавать session_id, поскольку она не должна выдавать результаты запроса одного пользователя другому пользователю.
- Надо будет добавить и третью ручку, /v1/chats/search/{task_id}/messages которая позволяет получать результаты таски, со смещением и лимитом, которые указываются в запросе, наподобие того, как мы ищем сообщения в самом чате. Ручке необходимо передавать session_id, поскольку она не должна выдавать результаты запроса одного пользователя другому пользователю.
- (*) Возможно, стоит выводить сообщения с некоторой долей отклонения, например, по Левенштейну, воспользовавшись такой структурой, как BK-Tree.
- (*) Возможно, стоит сделать фоновый процесс, который будет зачищать отработавшие таски, поскольку иначе база будет пухнуть от информации поиска.
- (*) Также стоит установить таске таймаут, учитывая, что пользователь вряд ли будет ждать дольше 5 секунд, пока мессенджер что-то высветит, после чего таска должна прекратить работу, и вывести то, что уже нашла.

Описанные ручки представлены ниже в формате OpenAPI:

```yaml
openapi: "3.0.0"
info:
  version: 1.0.0
  title: Gentlemen Messenger API
servers:
  - url: http://localhost
paths:
  /v1/chats/search:
    post:
      description: "Запустить процесс поиска по истории сообщений для чатов, в которых есть данный пользователь"      
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: "object"
              properties:
                message:
                  type: string
                  description: "текст сообщения, который надо найти в истории"
                  example: "Hello"
      responses:
        '201':
          $ref: '#/components/responses/GetHistoryResponse'
        '400':
          description: |
            * `bad-parameters` - неправильный формат входных параметров
        '404':
          description: |            
            * `user-not-found` - данный пользователь не найден
          
        default:
          $ref: '#/components/responses/DefaultErrorResponse'

  /v1/chats/search/status/{task_id}:
    get:
      description: "Получить статус таски на обработку"
      parameters:
        - in: path
          required: true
          name: task_id
          schema:
            type: string
      responses:
        '200':
          $ref:  "#/components/responses/GetTaskResponse"
        '400':
          description: |
            * `bad-parameters` - неправильный формат входных параметров
        '404':
          description: |            
            * `task-not-found` - задача на обработку не найдена
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
   
  /v1/chats/search/{task_id}/messages:
    get:
      description: "получить список сообщений из чатов"
      parameters:
        - in: path
          required: true
          name: task_id
          schema:
            type: string
          example: "the-task-id"
        - in: query
          required: true
          name: limit
          schema:
            type: integer
            minimum: 1
            maximum: 1000
          description: "не больше стольки сообщений хотим получить в ответе"
          example: 10
        - in: query
          name: from
          schema:
            $ref: '#/components/schemas/Cursor'
          description: "указатель для сервера, обозначающий место, с которого стоит продолжить получение сообщений; если не указан, то сервер должен вернуть limit сообщений, начиная с самого последнего сообщения в истории"
      responses:
        '200':
          $ref: '#/components/responses/HistoryGetMessagesResponse'
        '400':
          description: |
            * `bad-parameters` - неправильный формат входных параметров
        '404':
          description: |
            * `task-not-found` - указанная задача не существует
        default:
          $ref: '#/components/responses/DefaultErrorResponse'

components:
  responses:
    DefaultErrorResponse:
      description: 'unexpected server error'
      content:
        application/json:
          schema:
            required:
              - message
            properties:
              message:
                type: string
                description: "error reason"

    GetHistoryResponse:
      description: "Задача создана успешно"
      content:
        application/json:
          schema:
            required:
              - task_id
            properties:
              task_id:
                type: string
                description: "Идентификатор созданной задачи"

    GetTaskResponse:
      description: "Получить статус задачи"
      content:
        application/json:
          schema:
            required:
              - status
            properties:
              status:
                type: string
                description: "Статус задачи. Может принимать значения SUCCESS|IN_PROCESS|WAITING|FAILED"

    HistoryGetMessagesResponse:
      description: 'action was completed successfully'
      content:
        application/json:
          schema:
            required:
              - messages
            properties:
              messages:
                type: array
                items:
                  $ref: '#/components/schemas/HistoryMessage'
              next:
                $ref: '#/components/schemas/Cursor'

  schemas:
    HistoryMessage:
      properties:
        text:
          type: string
        chat_id:
          type: string

    Cursor:
      required:
        - iterator
      properties:
        iterator:
          type: string
```

## Чек-лист

- Реализован указанные эндпойнты.
- Полученные фразы в поиске отсортированы по дате, т.е. сначала должны идти самые новые сообщения.
- Поставлена отсечка, по итогам таска должна хранить не более 100 сообщений.
- Приложение возвращает 400 в случае, если указана фраза в тексте не более 3 символов (т.е. по идее фронтенд потом не должен отсылать запросы, если в поле поиска больно короткое слово).
- (*) Через 5 минут после завершения таска и ее данные удаляются фоновым процессом.
- (*) Фразы с отклонением в 2-3 символа также находятся в истории сообщений.


# Домашнее задание к 7 лекции

## TL;DR
Написать ansible playbook, который:
* Запустит контейнер с базой данных
* Запустит контейнер с приложением

### Выполнение
1. Сделайте ветку `ansible` в репозитории с вашим проектом
2. В ветке `ansible` в корне нужно создать 2 файла
* `.gitlab-ci.yml` следующего содержания:
```yml
include:
  - project: 'school/2021-09/backend/python/homeworks/7' # или 'school/2021-09/backend/java/homeworks/7' 
    ref: master
    file: '.gitlab-ci.yml'
    
variables:
  APP_PORT: 8080 # порт, который слушает приложение при запуске
  LANG: python # или java
```
* `playbook.yml`, содержащий playbook для запуска контейнеров
3. Создайте MR ветки `ansible` в `master`
4. Проверка MR должна быть зеленой

## Нюансы
* В корне должен лежать `Dockerfile`, сборка контейнера будет выполняться командой `docker build -t $CI_REGISTRY_IMAGE .`
* Для указания образа внутри `playbook.yml` используйте `{{ lookup('env', 'CI_REGISTRY_IMAGE') }}`, аналогично для проброса портов можно использовать переменную окружения APP_PORT

## Как разрабатывать локально
1. Устанавливаем зависимости: `pip install ansible==4.7.0 docker==5.0.2 docker-compose==1.29.2`
2. Пишем `playbook.yml`
3. Запускаем `ansible-playbook`. Т.к. у нас нет похода по ssh, применять мы будем локально: `ansible-playbook -c local -i localhost playbook.yml`

## Варианты реализации
1. Описать явно в `playbook`'e `docker_network`, 2 `docker_container`, пробросить порты, задать обоим контейнерам общую сеть
2. Написать `docker-compose.yml` и применить его через `docker_compose` в `playbook`'e

## Подсказки
1. https://github.com/grigory51/shbr-devops/tree/master/presentation/03-run-ansible
2. https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.html
3. https://docs.ansible.com/ansible/latest/collections/community/docker/docker_network_module.html
4. https://docs.ansible.com/ansible/latest/collections/community/docker/docker_compose_module.html
5. https://docs.ansible.com/ansible/latest/collections/ansible/builtin/wait_for_module.html

# Домашнее задание к 4 лекции

В рамках этого ДЗ нужно сделать интеграцию сервиса с БД, то есть сохранять историю и состав чатов в БД.

### Условие
1. Добавьте в спеку и реализуйте http-endpoint /ping\_db, который будет являться маркером успешной работы БД. Если БД доступна приложению, endpoint должен возвращать ответ с кодом 200. Если БД не доступна приложению, endpoint должен возвращать ответ с кодом 503 с понятным сообщением об ошибке.
2. Теперь состав чатов и историю сообщений необходимо сохранять в БД. Если приложение сообщило об успешном выполнении запроса, то при перезагрузке приложения или временном отключении БД соответствующие данные не должны никуда пропасть.
3. (\*) Наш мессенджер стал популярным настолько, что им заинтересовались не только джентльмены. Если запрос приходит только с user\_id, доверять ему не следует. Добавьте в мессенджер возможность зарегистрироваться по паре логин + пароль. Вместо того, чтобы завставлять клиента передавать во всех запросах логин + пароль, можно при логине выписать пользователю временный session\_id. Спека будет дополнена описанием необходимых endpoint'ов.
4. (\*) Доступ к основной функциональности мессенджера должен быть только у аутентифицированных пользователей. Но для тестов имеет смысл предусмотреть возможность упрощенной аутентификации или полного ее отключения.
5. Мы заметили, что какой-то пользователь начал отправлять десятки сообщений в секунду. Слишком быстро печатает для человека. Что бы нам такого придумать, чтобы быстро предотвратить нецелевое использование нашего мессенджера? Что можно сделать, чтобы вообще не допустить возникновения такой ситуации? Подсказка: почитайте описания http кода 429
6. (\*) Те же вопросы, но для API аутентификации.

### Чек-лист
1. Реализован endpoint /ping\_db
2. Приложение сохраняет состав чатов и историю сообщений в БД. После перезапуска приложения данные не должны пропадать.
3. Если произошло временное отключение БД, после восстановления БД приложение должно восстановить свою работоспособность. По логам приложения можно понять в какие периоды БД была не доступна.
4. Если БД не доступна, приложение должно оставаться функциональным.
5. Создание всех таблиц должно производиться с помощью правильных инструментов миграции. Обязательно использовать Liquibase для миграций, потому что мы хотим проверять можно ли откатить все миграции.
6. (\*) В мессенджере можно зарегистрироваться, залогиниться и разлогиниться. Доступ к основной функциональности мессенджера есть только у залогиненных пользователей.
7. (\*) Клиенты от имени пользователя могут получать сообщения только из тех чатов, где состоит этот пользователь.

### На что обратить внимание
1. При работе с БД используйте пулы соединений, чтобы модерировать нагрузку на БД.
2. Посмотрите как устроен PreparedStatement. Имеет ли смысл использовать его в вашей реализации мессенджера? В каких местах?
3. Подумайте в каких методах мессенджера мог бы использоваться batch insert?
4. Существует несколько практик миграций. Например, миграции может осуществлять отдельный изолированный сервис или же само приложение на старте. Подумайте какие преимущества и недостатки у существующих подходов.
5. Пользователи мессенджера могут оказаться совсем не джентльменами. Подумайте возможны ли SQL-инъекции в ваше приложение. Как от них защититься?
6. Ошибки исполнения запросов к БД не должны вываливаться на пользователя в необработанном виде.
7. Не стоит писать в лог или задействовать в сообщении об ошибках чувствительные данные (пароли к БД, пароли к аккаунтам пользователей, session\_id).

### Как будет производиться тестирование
* Рядом с контейнером мессенджера будет подниматься чистый контейнер с postgresql 12. connection\_string к нему будет опубликован позднее.
* Контейнер с приложением будет считаться поднятым только после того, как endpoint /ping\_db начнет отвечать с кодом 200.
* В тестах могут быть затронуты произвольные описанные в спеке endpoint'ы.
* Будет проверяться наличие миграций и корректная их накатка\откатка
